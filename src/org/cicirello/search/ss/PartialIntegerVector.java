/*
 * Chips-n-Salsa: A library of parallel self-adaptive local search algorithms.
 * Copyright (C) 2002-2020  Vincent A. Cicirello
 *
 * This file is part of Chips-n-Salsa (https://chips-n-salsa.cicirello.org/).
 * 
 * Chips-n-Salsa is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * Chips-n-Salsa is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

package org.cicirello.search.ss;


import org.cicirello.search.representations.IntegerVector;
import java.util.Arrays;

/**
 * <p>A PartialIntegerVector represents a vector of integers that is being 
 * iteratively constructed as a solution to an optimization problem
 * over the space of integer vectors.
 * This class supports the implementation of constructive heuristics 
 * for optimization problems where solutions are represented as a vector of integers, 
 * as well as for stochastic
 * sampling algorithms that rely on constructive heuristics.</p>
 *
 *
 * @author <a href=https://www.cicirello.org/ target=_top>Vincent A. Cicirello</a>, 
 * <a href=https://www.cicirello.org/ target=_top>https://www.cicirello.org/</a>
 * @version 9.9.2020
 */
public final class PartialIntegerVector implements Partial<IntegerVector> {
	
	private final int min;
	private final int max;
	private int extendCount;
	private final boolean enforceBounds;
	private final int[] partial;
	private int size;
	
	/**
	 * Constructs a PartialIntegerVector of a specified length with specified
	 * min and max values for the integers it contains.  The default behavior is
	 * for the final IntegerVector that is generated by this PartialIntegerVector
	 * to continue to enforce those bounds.
	 * @param n The desired length of the final IntegerVector, which must be non-negative. 
	 * @param min The minimum value for any individual integer in the vector.
	 * @param max The maximum value for any individual integer in the vector.
	 * @throws IllegalArgumentException if n is less than 0
	 * @throws IllegalArgumentException if min is greater than max
	 */
	public PartialIntegerVector(int n, int min, int max) {
		this(n, min, max, true);
	}
	
	/**
	 * Constructs a PartialIntegerVector.
	 * @param n The desired length of the final IntegerVector, which must be non-negative. 
	 * @param min The minimum value for any individual integer in the vector.
	 * @param max The maximum value for any individual integer in the vector.
	 * @param enforceBounds If true, then the final IntegerVector generated by this PartialIntegerVector
	 * will continue to enforce the min and max bounds during subsequent changes.
	 * @throws IllegalArgumentException if n is less than 0
	 * @throws IllegalArgumentException if min is greater than max
	 */
	public PartialIntegerVector(int n, int min, int max, boolean enforceBounds) {
		if (n < 0) throw new IllegalArgumentException("n must not be negative");
		if (min > max) throw new IllegalArgumentException("min must be less than or equal to max");
		this.min = min;
		this.max = max;
		extendCount = max - min + 1;
		this.enforceBounds = enforceBounds;
		partial = new int[n];
		// deliberately using default of size=0
	}
	
	@Override
	public IntegerVector toComplete() {
		if (size < partial.length) {
			Arrays.fill(partial, size, partial.length, min);
		}
		return enforceBounds ? 
			new BoundedIntegerVector(partial, min, max) : 
			new IntegerVector(partial);
	}
	
	@Override
	public boolean isComplete() {
		return size == partial.length;
	}
	
	@Override
	public int get(int index) {
		if (index >= size) {
			throw new ArrayIndexOutOfBoundsException("index must be less than size");
		}
		return partial[index];
	}
	
	@Override
	public int getLast() {
		return partial[size-1];
	}
	
	@Override
	public int size() {
		return size;
	}
	
	@Override
	public int numExtensions() {
		return extendCount;
	}
	
	@Override
	public int getExtension(int extensionIndex) {
		if (extensionIndex >= extendCount) {
			throw new ArrayIndexOutOfBoundsException("extensionIndex must be less than numExtensions()");
		}
		return min + extensionIndex;
	}
	
	@Override
	public void extend(int extensionIndex) {
		if (extensionIndex >= extendCount) {
			throw new ArrayIndexOutOfBoundsException("extensionIndex must be less than numExtensions()");
		}
		partial[size] = min + extensionIndex;
		size++;
		if (size == partial.length) extendCount = 0;
	}
	
	private static final class BoundedIntegerVector extends IntegerVector {
		
		private final int min;
		private final int max;
		
		BoundedIntegerVector(int[] x, int min, int max) {
			super(x);
			this.min = min;
			this.max = max;
		}
		
		BoundedIntegerVector(BoundedIntegerVector other) {
			super(other);
			min = other.min;
			max = other.max;
		}
		
		/**
		 * Sets a parameter to a specified value, subject to the
		 * lower and upper bounds for this function input.  If the specified
		 * new value is less than the min, then the function input is set to
		 * the min.  If the specified new value is greater than the max, then
		 * the function input is set to the max.  Otherwise, the function input
		 * is set to the specified value.
		 * @param i The input to set.
		 * @param value The new value for the i-th function input.
		 * @throws ArrayIndexOutOfBoundsException if i &lt; 0 or i &ge; length().
		 */
		@Override
		public final void set(int i, int value) {
			if (value < min) super.set(i, min);
			else if (value > max) super.set(i, max);
			else super.set(i, value);
		}
		
		/**
		 * Creates an identical copy of this object.
		 * @return an identical copy of this object
		 */
		@Override
		public BoundedIntegerVector copy() {
			return new BoundedIntegerVector(this);
		}
		
		/**
		 * Indicates whether some other object is "equal to" this one.
		 * To be equal, the other object must be of the same runtime type and contain the
		 * same values and bounds.
		 * @param other The other object to compare.
		 * @return true if other is not null, is of the same runtime type as this, and contains
		 * the same values and bounds.
		 */
		@Override
		public boolean equals(Object other) {
			if (!super.equals(other)) return false;
			BoundedIntegerVector b = (BoundedIntegerVector)other;
			return min == b.min && max == b.max;
		}
		
		/**
		 * Returns a hash code value.
		 * @return a hash code value
		 */
		@Override
		public int hashCode() {
			int hash;
			hash = 31 * (31 + min) + max;
			int L = length();
			for (int i = 0; i < L; i++) {
				hash = 31 * hash + get(i);
			}
			return hash;
		}
	}
}